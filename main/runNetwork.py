"""
The code below is automatically generated by NuPIC Studio and aims to help you to quickly integrate
this HTM network into your application using the NuPIC Network API.
For use this code, just create a new Python file and copy/paste these lines into it. Run it and voila!
"""
import numpy
import json
import copy
from nupic.algorithms.anomaly import computeRawAnomalyScore
from nupic.data.file_record_stream import FileRecordStream
from nupic.engine import Network
from nupic.encoders import MultiEncoder


def createNetwork():
  """
  Create the Network instance.
  """

  network = Network()

  # Create "Top" region
  global spB1
  spB1 = createRegion(network=network, name="BottomRegion", 
               spParams={  'columnCount': 2048,
                                 'globalInhibition': 1,
                                 'inputWidth': 3200,
                                 'maxBoost': 2.0,
                                 'numActiveColumnsPerInhArea': 42,
                                 'potentialPct': 0.8,
                                 'potentialRadius': 4,
                                 #'stimulusThreshold': 5,
                                 'seed': 1956,
                                 'spVerbosity': 0,
                                 'spatialImp': 'cpp',
                                 'synPermActiveInc': 0.05,
                                 'synPermConnected': 0.1,
                                 'synPermInactiveDec': 0.0121},
               tpParams={ 'activationThreshold': 12,
                                 'cellsPerColumn': 1,
                                 'columnCount': 2048,
                                 'globalDecay': 0.0,
                                 'initialPerm': 0.21,
                                 'inputWidth': 2048,
                                 'maxAge': 0,
                                 'outputType': 'activeState',
                                 'permanenceDec': 0.1,
                                 'permanenceInc': 0.1,
                                 'seed': 1960,
                                 'temporalImp': 'cpp',
                                 'verbosity': 0, 
                         'outputType' : 'normal' })
  global spB2
  spB2 = createRegion(network=network, name="BottomRegion2", 
               spParams={  'columnCount': 2048,
                                 'globalInhibition': 1,
                                 'inputWidth': 3200,
                                 'maxBoost': 2.0,
                                 'numActiveColumnsPerInhArea': 42,
                                 'potentialPct': 0.8,
                                 'potentialRadius': 32,
                                 #'stimulusThreshold': 5,
                                 'seed': 1944,
                                 'spVerbosity': 0,
                                 'spatialImp': 'cpp',
                                 'synPermActiveInc': 0.05,
                                 'synPermConnected': 0.1,
                                 'synPermInactiveDec': 0.0121},
               tpParams={ 'activationThreshold': 12,
                                 'cellsPerColumn': 1,
                                 'columnCount': 2048,
                                 'globalDecay': 0.0,
                                 'initialPerm': 0.21,
                                 'inputWidth': 2048,
                                 'maxAge': 0,
                                 'outputType': 'activeState',
                                 'permanenceDec': 0.1,
                                 'permanenceInc': 0.1,
                                 'seed': 1919,
                                 'temporalImp': 'cpp',
                                 'verbosity': 0, 
                         'outputType' : 'normal' })
    
  global spB3
  spB3 = createRegion(network=network, name="BottomRegion3", 
               spParams={  'columnCount': 2048,
                                 'globalInhibition': 1,
                                 'inputWidth': 2400,
                                 'maxBoost': 2.0,
                                 'numActiveColumnsPerInhArea': 42,
                                 'potentialPct': 0.8,
                                 'potentialRadius': 32,
                                 #'stimulusThreshold': 5,
                                 'seed': 1901,
                                 'spVerbosity': 0,
                                 'spatialImp': 'cpp',
                                 'synPermActiveInc': 0.05,
                                 'synPermConnected': 0.1,
                                 'synPermInactiveDec': 0.0121},
               tpParams={ 'activationThreshold': 12,
                                 'cellsPerColumn': 1,
                                 'columnCount': 2048,
                                 'globalDecay': 0.0,
                                 'initialPerm': 0.21,
                                 'inputWidth': 2048,
                                 'maxAge': 0,
                                 'outputType': 'activeState',
                                 'permanenceDec': 0.1,
                                 'permanenceInc': 0.1,
                                 'seed': 1910,
                                 'temporalImp': 'cpp',
                                 'verbosity': 0, 
                         'outputType' : 'normal' })

  # Create Sensors
  createSensor(network=network, name="Costs", params={ 'verbosity': 0 }, dataFile="./Swift3.csv", 
               encodings={ 'GALLONS':       { 'name': 'GALLONS',    'fieldname': 'FMDL_TR_TRACTOR_GALLONS', 'resolution': 2.0, 'type': 'RandomDistributedScalarEncoder' }, 
                           'TRACTOR_COST':  { 'name': 'TRACTOR_COST', 'fieldname': 'FMDL_SC_TR_TRACTOR_COST', 'resolution': 5.0, 'type': 'RandomDistributedScalarEncoder' }, 
                           'FUEL_RATE':  { 'name': 'FUEL_RATE', 'fieldname': 'FMDL_RD_FUEL_RATE', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'PROD_CODE':     { 'name': 'PROD_CODE',  'fieldname': 'FMDL_NR2_SUB_PROD_CODE', 'n': 400, 'w': 21, 'forced': 'True', 'type': 'SDRCategoryEncoder' }, 
                           'SC_CODE':       { 'name': 'SC_CODE',  'fieldname': 'FMDL_SETTLEMENT_SC_CODE', 'n': 400, 'w': 21, 'forced': 'True', 'type': 'SDRCategoryEncoder' }, 
                           'SC_DISCOUNT':   { 'name': 'SC_DISCOUNT', 'fieldname': 'FMDL_RD_SC_SELECT_DISCOUNT', 'resolution': 0.01, 'type': 'RandomDistributedScalarEncoder' }, 
                           'TRAN_FEE':        { 'name': 'TRAN_FEE', 'fieldname': 'FMDL_RD_SC_TRANSACTION_FEE', 'resolution': 0.01, 'type': 'RandomDistributedScalarEncoder' }, 
                           'UNIT_NUM':        { 'name': 'UNIT_NUM', 'fieldname': 'FMDL_DT_UNIT_NUMBER', 'resolution': 1, 'type': 'RandomDistributedScalarEncoder' }, 
                           'COMDATA_FEES':  { 'name': 'COMDATA_FEES', 'fieldname': 'FMDL_COMDATA_FEES', 'resolution': 0.01, 'type': 'RandomDistributedScalarEncoder' }, })


  createSensor(network=network, name="PPGS", params={ 'verbosity': 0 }, dataFile="./Swift3.csv", 
               encodings={ 'TRACTOR_PPG':     { 'name': 'TRACTOR_PPG', 'fieldname': 'FMDL_SC_TR_TRACTOR_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'TRAN_PPG':        { 'name': 'TRAN_PPG', 'fieldname': 'FMDL_CP_DIESEL_TRAN_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'PPG_NR2':    { 'name': 'PPG_NR2', 'fieldname': 'FMDL_RETAIL_PPG_NR2', 'resolution': 0.01, 'type': 'RandomDistributedScalarEncoder' }, 
                           'PLUS_PPG':      { 'name': 'PLUS_PPG',  'fieldname': 'FMDL_COST_PLUS_NR2_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'RACK_PPG':      { 'name': 'RACK_PPG',  'fieldname': 'FMDL_CP_NR2_RACK_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'LUST_PPG':      { 'name': 'LUST_PPG',  'fieldname': 'FMDL_CP_DIESEL_LUST_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'MISC_PPG':      { 'name': 'MISC_PPG',  'fieldname': 'FMDL_CP_REEFER_MISC_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'TAX_PPG':      { 'name': 'TAX_PPG',  'fieldname': 'FMDL_CP_DIESEL_ST_TAX_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, })

  createSensor(network=network, name="Reefers", params={ 'verbosity': 0 }, dataFile="./Swift3.csv",
               encodings={ 'ST_TAX_PPG':      { 'name': 'ST_TAX_PPG',  'fieldname': 'FMDL_CP_REEFER_ST_TAX_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'TRAN_PPG':      { 'name': 'TRAN_PPG',  'fieldname': 'FMDL_CP_REEFER_TRAN_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'ST_PPG':      { 'name': 'ST_PPG',  'fieldname': 'FMDL_CP_REEFER_ST_SF_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'MISC_PPG':      { 'name': 'MISC_PPG',  'fieldname': 'FMDL_CP_REEFER_MISC_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, 
                           'REEFER_LUST_PPG': { 'name': 'REEFER_LUST_PPG', 'fieldname': 'FMDL_CP_REEFER_LUST_PPG', 'resolution': 0.001, 'type': 'RandomDistributedScalarEncoder' }, })

  # Link Regions
  linkSensorToRegion(network=network, outName="Costs", inName="BottomRegion")
  linkSensorToRegion(network=network, outName="PPGS", inName="BottomRegion2")
  linkSensorToRegion(network=network, outName="Reefers", inName="BottomRegion3")
  
  # Create "TopRegion" region
  global spTop
  spTop = createRegion(network=network, name="TopRegion", 
               spParams={ 'columnCount': 2048,
                                 'globalInhibition': 1,
                                 'inputWidth': 6144,
                                 'maxBoost': 2,
                                 'numActiveColumnsPerInhArea': 41,
                                 'potentialPct': 0.9,
                                 'potentialRadius': 32,
                                 'globalInhibition': 1,
                                 'seed': 1926,
                                 'spVerbosity': 0,
                                 'spatialImp': 'cpp',
                                 'synPermActiveInc': 0.05,
                                 'synPermConnected': 0.1,
                                 'synPermInactiveDec': 0.0125},
               tpParams={ 'activationThreshold': 12,
                                 'cellsPerColumn': 1,
                                 'columnCount': 2048,
                                 'globalDecay': 0.0,
                                 'initialPerm': 0.21,
                                 'inputWidth': 2048,
                                 #'maxAge': 0,
                                 #'maxSegmentsPerCell': 128,
                                 #'maxSynapsesPerSegment': 32,
                                 #'minThreshold': 10,
                                 'newSynapseCount': 20,
                                 #'pamLength': 1,
                                 'permanenceDec': 0.1,
                                 'permanenceInc': 0.1,
                                 'seed': 1932,
                                 'temporalImp': 'cpp',
                                 'verbosity': 0, })
  
  #Link Bottom region to Top region
  linkRegionToRegion(network=network, outName="BottomRegion", inName="TopRegion")
  linkRegionToRegion(network=network, outName="BottomRegion2", inName="TopRegion")
  linkRegionToRegion(network=network, outName="BottomRegion3", inName="TopRegion")

  return network

def createRegion(network, name, spParams, tpParams):
  """
  Create a region given SP and TP parameters.
  """

  # Create spatial node
  spNode = network.addRegion(name="sp" + name, nodeType="py.SPRegion", nodeParams=json.dumps(spParams)).getSelf()
  spNode.learningMode = True
  spNode.anomalyMode = True 
  
  # Create temporal node
  tpNode = network.addRegion(name="tp" + name, nodeType="py.TPRegion", nodeParams=json.dumps(tpParams)).getSelf()
  tpNode.learningMode = True
  tpNode.inferenceMode = True
  tpNode.topDownMode = True
  tpNode.anomalyMode = False

  # Create link betwen SP and TP of the same region
  network.link(srcName="sp" + name, destName="tp" + name, linkType="UniformLink", linkParams="")

  return spNode
  ##network.link(srcName="tp" + name, destName="sp" + name, linkType="UniformLink", linkParams="", srcOutput="topDownOut", destInput="topDownIn")

def createSensor(network, name, params, dataFile, encodings):
  """
  Create a sensor given its parameters.
  """

  # Create database given file name
  dataSource = FileRecordStream(streamID=dataFile)
  dataSource.setAutoRewind(True)

  # Create multi-encoder to handle all sub-encoders
  encoder = MultiEncoder()
  encoder.addMultipleEncoders(fieldEncodings=encodings)

  # Create sensor node
  sensor = network.addRegion(name="sensor" + name, nodeType="py.RecordSensor", nodeParams=json.dumps(params)).getSelf()
  sensor.dataSource = dataSource
  sensor.encoder = encoder

def linkRegionToRegion(network, outName, inName):
  """
  Create links between a region and another higher one in the hierarchy.
  """

  # Create link between TP from first region and SP of second region
  network.link(srcName="tp" + outName, destName="sp" + inName, linkType="UniformLink", linkParams="")

def linkSensorToRegion(network, outName, inName):
  """
  Create links between sensor and region in the hierarchy.
  """

  # Create link between Sensor and SP of the region
  network.link(srcName="sensor" + outName, destName="sp" + inName, linkType="UniformLink", linkParams="")

def runNetwork(network, numIterations):
  """
  Run the network up to n iterations.
  """

  network.initialize()

  # Only encodings with "EnableInference" turned "ON" will be printed
  links = []
  links.append({ "sensorName": "Costs", "regionName": "TopRegion", "encodings": [["GALLONS", 2], ], "prevPredictedColumns": [] })

  # Run the network showing current values from sensors and their anomaly scores
  printRow("Iter", "Sensor", "Encoding", "Current", "Anomaly Score")
  print network.regions.keys()
  rg = network.regions["spTopRegion"]
  rg.setParameter("learningMode", False)
  for i in range(numIterations):
    network.run(1)      

    if i == 50:
        spB1.learningMode = False
        spB2.learningMode = False
        spB3.learningMode = False
        spTop.learningMode = False

    for link in links:
      sensorName = link["sensorName"]
      regionName = link["regionName"]
      encodings = link["encodings"]
      prevPredictedColumns = link["prevPredictedColumns"]

      sensorNode = network.regions["sensor" + sensorName]
      spNode = network.regions["sp" + regionName]
      tpNode = network.regions["tp" + regionName]

      # The anomaly score is relation of active columns over previous predicted columns
      activeColumns = spNode.getOutputData("bottomUpOut").nonzero()[0]
      anomalyScore = computeRawAnomalyScore(activeColumns, prevPredictedColumns)

      # Print the anomaly score along with the iteration number and current value of this encoding.
      for encoding in encodings:
        encodingFieldName = encoding[0]
        encodingFieldIdx = encoding[1]
        currValue = sensorNode.getOutputData("sourceOut")[encodingFieldIdx]
        printRow(i, sensorName, encodingFieldName, currValue, anomalyScore)

      # Store the predicted columns for the next iteration
      predictedColumns = tpNode.getOutputData("topDownOut").nonzero()[0]
      link["prevPredictedColumns"] = copy.deepcopy(predictedColumns)

def printRow(iter, sensorName, encodingFieldName, currValue, anomalyScore):
    
  iter = str(iter).rjust(10) + " "
  sensorName = str(sensorName).ljust(20) + " "
  encodingFieldName = str(encodingFieldName).ljust(25) + " "
  currValue = str(currValue).rjust(15) + " "
  anomalyScore = str(anomalyScore).ljust(40)
  print iter, sensorName, encodingFieldName, currValue, anomalyScore

if __name__ == "__main__":
  network = createNetwork()

  numIterations = input("Type the number of iterations: ")
  runNetwork(network, numIterations)

